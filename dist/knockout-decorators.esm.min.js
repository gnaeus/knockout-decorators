import{computed as e,components as t,utils as n,subscribable as r,observableArray as o,observable as u}from"knockout";const c="__ko_decorators_";let s=c+"patched__",i=c+"extenders__",l=c+"subscriptions__";"undefined"!=typeof Symbol&&(s=Symbol(s),i=Symbol(i),l=Symbol(l));const a=Array.prototype;function f(e,t,n){n.configurable=!0,Object.defineProperty(e,t,n)}const b=n.extend,v=n.objectForEach,h=Array.isArray.bind(Array),p=Object.getPrototypeOf.bind(Object),d=Object.getOwnPropertyDescriptor.bind(Object),m=Function.prototype.call.bind(Object.prototype.hasOwnProperty),y=Function.prototype.call.bind(a.slice);function g(e,t){const n=new r,o=function(){const e=y(arguments);n.notifySubscribers(e)};return o.subscribe=function(e){return n.subscribe(function(t){e.apply(null,t)})},f(e,t,{value:o}),o}function w(e,t,n){const r=e[i],o=r&&r[t];return o&&o.forEach(t=>{const r=t instanceof Function?t.call(e):t;n=n.extend(r)}),n}function j(e,t,n){let r=e[i];m(e,i)||(e[i]=r=b({},r),v(r,(e,t)=>{r[e]=[...t]})),(r[t]||(r[t]=[])).push(n)}function _(e,t,n,r,o){const c=w(e,t,u());let s=c;r&&(s=function(e){c(O(e,o))}),f(e,t,{enumerable:!0,get:c,set:s}),o&&f(e,"_"+t.toString(),{enumerable:!1,value:c}),s(n)}function O(e,t){if("object"==typeof e){if(h(e)||null===e)return e;if(m(e,"constructor")){const n=p(e);if(n===Object.prototype||null===n)return A(e,t)}else if(e.constructor===Object)return A(e,t)}return e}function A(e,t){return m(e,s)||(f(e,s,{value:!0}),v(e,(n,r)=>{h(r)?F(e,n,r,!0,t):_(e,n,r,!0,t)})),e}const k=["pop","reverse","shift","sort"],x=[...k,"push","splice","unshift"],S=["remove","removeAll","destroy","destroyAll","replace","subscribe"],C=[...S,"replace"],E=[...x,...C,"mutate","set"];function F(e,t,n,r,u){const c=w(e,t,o());let i=!1;function l(e){const t=c.peek();if(t!==e&&(h(t)&&m(t,s)&&(delete t[s],E.forEach(e=>{delete t[e]})),h(e))){if(m(e,s)&&(e=[...e]),r)for(let t=0;t<e.length;++t)e[t]=O(e[t],u);f(e,s,{value:!0}),n=e,(r?k:x).forEach(e=>f(n,e,{value(){if(i)return a[e].apply(n,arguments);i=!0;const t=c[e].apply(c,arguments);return i=!1,t}})),(r?S:C).forEach(e=>f(n,e,{value(){i=!0;const t=c[e].apply(c,arguments);return i=!1,t}})),r?(f(n,"push",{value(){if(i)return a.push.apply(n,arguments);const e=y(arguments);for(let t=0;t<e.length;++t)e[t]=O(e[t],u);i=!0;const t=c.push.apply(c,e);return i=!1,t}}),f(n,"unshift",{value(){if(i)return a.unshift.apply(n,arguments);const e=y(arguments);for(let t=0;t<e.length;++t)e[t]=O(e[t],u);i=!0;const t=c.unshift.apply(c,e);return i=!1,t}}),f(n,"splice",{value(){if(i)return a.splice.apply(n,arguments);let e;switch(i=!0,arguments.length){case 0:case 1:case 2:e=c.splice.apply(c,arguments);break;case 3:e=c.splice(arguments[0],arguments[1],O(arguments[2],u));break;default:{const t=y(arguments);for(let e=2;e<t.length;++e)t[e]=O(t[e],u);e=c.splice.apply(c,arguments);break}}return i=!1,e}}),f(n,"replace",{value(e,t){i=!0;const n=c.replace(e,O(t,u));return i=!1,n}}),f(n,"mutate",{value(e){const t=c.peek();c.valueWillMutate(),e(t);for(let e=0;e<t.length;++e)t[e]=O(t[e],u);c.valueHasMutated()}}),f(n,"set",{value:(e,t)=>c.splice(e,1,O(t,u))[0]})):(f(n,"mutate",{value(e){c.valueWillMutate(),e(c.peek()),c.valueHasMutated()}}),f(n,"set",{value:(e,t)=>c.splice(e,1,t)[0]}))}var n;i=!0,c(e),i=!1}f(e,t,{enumerable:!0,get:c,set:l}),u&&f(e,"_"+t.toString(),{enumerable:!1,value:c}),l(n)}function M(e,t){return z=!1,N=!1,V=!1,1===arguments.length?(N=e.deep,V=e.hiddenObservable,D):D(e,t)}function q(e,t){return z=!0,N=!1,V=!1,1===arguments.length?(N=e.deep,V=e.hiddenObservable,D):D(e,t)}let z,N,V,B;function D(e,t){const n=z,r=N,o=V;f(e,t,{get(){throw new Error("@observable property '"+t.toString()+"' was not initialized")},set(e){n||h(e)?F(this,t,e,r,o):_(this,t,e,r,o)}})}function G(e,t,n){return B={pure:!0},1===arguments.length?(B=e,H):H(e,t,n)}function H(t,n,r){const o=B,{get:u,set:c}=r||(r=d(t,n));if(!u)throw new Error("@computed property '"+n.toString()+"' has no getter");return r.get=function(){const t=w(this,n,e(u,this,o));return f(this,n,{get:t,set:c}),t()},r}function I(e){return function(t,n){j(t,n,e)}}function J(e,n,r,o){return void 0===o&&(void 0===r?"object"!=typeof n||n.constructor!==Object||"require"in n||"element"in n||(o=n,n=void 0):"object"==typeof r&&(o=r,r=void 0)),function(r){t.register(e,b({viewModel:r.length<2?r:{createViewModel:(e,{element:t,templateNodes:n})=>new r(e,t,n)},template:n||"\x3c!----\x3e",synchronous:!0},o))}}function K(e,t,n){const{value:r,configurable:o,enumerable:u}=n||(n=d(e,t));return{configurable:o,enumerable:u,get(){if(this===e)return r;const n=r.bind(this);return f(this,t,{value:n}),n}}}function L(e,t){f(e,t,{get(){return g(this,t)}})}function P(t,n,r){const o=r&&r.once||!1;if(m(t,"subscribe")){const e=t;if(o){const t=e.subscribe(function(){t.dispose(),n.apply(null,arguments)});return t}return e.subscribe(n)}{const u=r&&r.event||"change";let c,i;if(c=o?function(){i.dispose(),n.apply(null,arguments)}:n,"arrayChange"===u){const e=t();if(!h(e)||!m(e,s))throw new Error("Can not subscribe to 'arrayChange' because dependency is not an 'observableArray'");i=e.subscribe(c,null,u)}else{const n=e(t),r=(i=n.subscribe(c,null,u)).dispose;i.dispose=function(){r.call(this),n.dispose()}}return i}}function Q(e,t){return m(e,t)||e[t],d(e,t).get}function R(e){return void 0===e&&(e=class{}),class extends e{dispose(){const e=this[l];e&&(e.forEach(e=>{e.dispose()}),delete this[l])}subscribe(){const e=P.apply(null,arguments);return(this[l]||(this[l]=[])).push(e),e}unwrap(e){return Q(this,e)}}}export{M as observable,q as observableArray,G as computed,I as extend,J as component,K as autobind,L as event,P as subscribe,Q as unwrap,R as Disposable};
//# sourceMappingURL=knockout-decorators.esm.min.js.map
